# Reference used: 
## https://dzone.com/articles/algorithm-week-homomorphic
## Sub References: https://www.cs.cmu.edu/~rwh/theses/okasaki.pdf, https://pdos.csail.mit.edu/papers/otfvec/paper.pdf, 

# here, sum = a + b + c + d + e -> sum is the key and a, b, ..., e are the subkeys that are generated from the key
# the homomorphic hash function is H(x) = g^x mod q
# Properties of a Homomorphic Function: kH(m + n + o) = H(km) + H(kn) + H(ko) = kH(m) + kH(n) + kH(o)

'''
####
To be defined: 
PASS_LEN - maximum length for the message / password
BLOCK_LEN - maximum length of the blocks that the message is split into
####
'''

import random
import math
import pickle

def isPrime(x: int) -> bool:
    for i in range(2, math.sqrt(x) + 1):
        if(x%i == 0): return False
    return True

def keygen(P = 101) -> list:
    keys = []
    i = 1
    while len(keys)<5:
        Q = P * i + 1
        print(Q)
        print(P%Q)
        if(isPrime(Q) and P % Q == 1):
            keys.append(i)
        i+=1

    print(f'keygen({P}): {keys}')
    # k = int(input("Enter index 0 to 4: ")) # random.randint(0, 4)
    return keys[random.randint(0, 4)]

def primegen(start = 101, step = 1) -> list:
    i = start
    primes = []
    while (len(primes) < 5):
        if(isPrime(i)):
            primes.append(i)
        i+=step

    print(f'primes({start}, {step}): {primes}')
    return primes

def HomoHash(a: int, b: int, x: int, k = 1) -> int:
    return pow(a, k*x, b)

def add(x: list, g: int, q: int, p: int, k = 1)  -> int:
    # need the column of the blocks
    # to compute the hash:
    ## compute the sum of the characters by adding each one
    ## hash that sum by raising g to the power of the sum (mod q)
    sum = 0
    for i in range(len(x)): # for i in x: sum+= i%p
        sum += (x[i] % p)
    return HomoHash(g, q, k*(sum%p))

def multiply(x: list, g: int, q: int, p: int, k = 1)  -> int:
    # need the column of the blocks
    # to compute the hash:
    ## compute the hash of each individual character by raising g to the power of the character (mod q)
    ## compute the "sum" of the hashes of the individual characters by multiplying them (mod q)
    product = 1
    # hashed_products are the keys computed by each individual server
    hashed_products = []
    for i in range(len(x)): # for i in x: 
        temp = HomoHash(g, q, k*x[i])
        hashed_products.append(temp)
        product *= temp
        product %= q
    print(hashed_products)
    return product

# Constants used in the hash function
## Choose prime p - 257
p = primegen() # public
## Choose q such that `q % p == 1` or `p | (q - 1)` - 257*6 + 1
q = [keygen(x) for x in p] # public
## a random number g
g = [random(100, 500) for i in range(5)] # public
## generate fuzz factors k
k = [random.randint(15, 100) for i in range(5)] # private
# hashes computed at each server, same length as the input + padding
h = [] # distributed

# Variables used in the script
# get password from the user
inp = input("10 Characters: ") # private
# hash message
m = [int(a) for a in inp] # private



print("message (primary key): ", m)
print("obfuscated sub keys (sent to each server): ", [i*j for (i, j) in zip(m, k)])
print("hashes (generated by each server): ", h)
print("sum_hash (hashing entire message - done by client): ", sum_hash)
print("product (hashing each block and then adding the hashes - done by the distributed network):", product_hash)
print("k_sum (obfuscated sum_hash): ", k_sum)
print("k_sum (obfuscated product_hash): ", k_product)

if(sum_hash == product_hash):
    print("Hashes are equal!")

if(k_sum == k_product):
    print("Obfuscated hashes are equal!")
